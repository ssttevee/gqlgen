package templates

var data = map[string]string{
	"args.gotpl":      "\t{{- if . }}args := map[string]interface{}{} {{end}}\n\t{{- range $i, $arg := . }}\n\t\tvar arg{{$i}} {{$arg.UnmarshaledSignature}}\n\t\tif tmp, ok := rawArgs[{{$arg.GQLName|quote}}]; ok {\n\t\t\tvar err error\n\t\t\t{{$arg.Unmarshal (print \"arg\" $i) \"tmp\" }}\n\t\t\tif err != nil {\n\t\t\t\tec.Error(ctx, err)\n\t\t\t\t{{- if $arg.Stream }}\n\t\t\t\t\treturn nil\n\t\t\t\t{{- else }}\n\t\t\t\t\treturn graphql.Null\n\t\t\t\t{{- end }}\n\t\t\t}\n\t\t}\n\t\targs[{{$arg.GQLName|quote}}] = arg{{$i}}\n\t{{- end -}}\n",
	"field.gotpl":     "{{ $field := . }}\r\n{{ $object := $field.Object }}\r\n\r\n{{- if $object.Stream }}\r\n\tfunc (ec *executionContext) _{{$object.GQLType}}_{{$field.GQLName}}(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {\r\n\t\t{{- if $field.Args }}\r\n\t\t\trawArgs := field.ArgumentMap(ec.Variables)\r\n\t\t\t{{ template \"args.gotpl\" $field.Args }}\r\n\t\t{{- end }}\r\n\t\tctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{Field: field})\r\n\t\tresults, err := ec.resolvers.{{ $field.ShortInvocation }}\r\n\t\tif err != nil {\r\n\t\t\tec.Error(ctx, err)\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn func() graphql.Marshaler {\r\n\t\t\tres, ok := <-results\r\n\t\t\tif !ok {\r\n\t\t\t\treturn nil\r\n\t\t\t}\r\n\t\t\tvar out graphql.OrderedMap\r\n\t\t\tout.Add(field.Alias, func() graphql.Marshaler { {{ $field.WriteJson }} }())\r\n\t\t\treturn &out\r\n\t\t}\r\n\t}\r\n{{ else }}\r\n\tfunc (ec *executionContext) _{{$object.GQLType}}_{{$field.GQLName}}(ctx context.Context, field graphql.CollectedField, {{if not $object.Root}}obj *{{$object.FullName}}{{end}}) graphql.Marshaler {\r\n\t\t{{- if $field.Args }}\r\n\t\t\trawArgs := field.ArgumentMap(ec.Variables)\r\n\t\t\t{{ template \"args.gotpl\" $field.Args }}\r\n\t\t{{- end }}\r\n\r\n\t\t{{- if $field.IsConcurrent }}\r\n\t\t\tctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{\r\n\t\t\t\tObject: {{$object.GQLType|quote}},\r\n\t\t\t\tArgs: {{if $field.Args }}args{{else}}nil{{end}},\r\n\t\t\t\tField: field,\r\n\t\t\t})\r\n\t\t\treturn graphql.Defer(func() (ret graphql.Marshaler) {\r\n\t\t\t\tdefer func() {\r\n\t\t\t\t\tif r := recover(); r != nil {\r\n\t\t\t\t\t\tuserErr := ec.Recover(ctx, r)\r\n\t\t\t\t\t\tec.Error(ctx, userErr)\r\n\t\t\t\t\t\tret = graphql.Null\r\n\t\t\t\t\t}\r\n\t\t\t\t}()\r\n\t\t{{ else }}\r\n\t\t\trctx := graphql.GetResolverContext(ctx)\r\n\t\t\trctx.Object = {{$object.GQLType|quote}}\r\n\t\t\trctx.Args = {{if $field.Args }}args{{else}}nil{{end}}\r\n\t\t\trctx.Field = field\r\n\t\t\trctx.PushField(field.Alias)\r\n\t\t\tdefer rctx.Pop()\r\n\t\t{{- end }}\r\n\t\t\tresTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {\r\n\t\t\t\t{{- if $field.IsResolver }}\r\n\t\t\t\t\treturn ec.resolvers.{{ $field.ShortInvocation }}\r\n\t\t\t\t{{- else if $field.IsMethod }}\r\n\t\t\t\t\t{{- if $field.NoErr }}\r\n\t\t\t\t\t\treturn {{$field.GoReceiverName}}.{{$field.GoFieldName}}({{ $field.CallArgs }}), nil\r\n\t\t\t\t\t{{- else }}\r\n\t\t\t\t\t\treturn {{$field.GoReceiverName}}.{{$field.GoFieldName}}({{ $field.CallArgs }})\r\n\t\t\t\t\t{{- end }}\r\n\t\t\t\t{{- else if $field.IsVariable }}\r\n\t\t\t\t\treturn {{$field.GoReceiverName}}.{{$field.GoFieldName}}, nil\r\n\t\t\t\t{{- end }}\r\n\t\t\t})\r\n\t\t\tif resTmp == nil {\r\n\t\t\t\treturn graphql.Null\r\n\t\t\t}\r\n\t\t\tres := resTmp.({{$field.Signature}})\r\n\t\t\t{{ $field.WriteJson }}\r\n\t\t{{- if $field.IsConcurrent }}\r\n\t\t\t})\r\n\t\t{{- end }}\r\n\t}\r\n{{ end }}\r\n",
	"generated.gotpl": "// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\r\n\r\npackage {{ .PackageName }}\r\n\r\nimport (\r\n{{- range $import := .Imports }}\r\n\t{{- $import.Write }}\r\n{{ end }}\r\n)\r\n\r\n// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.\r\nfunc NewExecutableSchema(cfg Config) graphql.ExecutableSchema {\r\n\treturn &executableSchema{\r\n\t\tresolvers: cfg.Resolvers,\r\n\t\tdirectives: cfg.Directives,\r\n\t}\r\n}\r\n\r\ntype Config struct {\r\n\tResolvers  ResolverRoot\r\n\tDirectives DirectiveRoot\r\n}\r\n\r\ntype ResolverRoot interface {\r\n{{- range $object := .Objects -}}\r\n\t{{ if $object.HasResolvers -}}\r\n\t\t{{$object.GQLType}}() {{$object.GQLType}}Resolver\r\n\t{{ end }}\r\n{{- end }}\r\n}\r\n\r\ntype DirectiveRoot struct {\r\n{{ range $directive := .Directives }}\r\n\t{{ $directive.Declaration }}\r\n{{ end }}\r\n}\r\n\r\n{{- range $object := .Objects -}}\r\n\t{{ if $object.HasResolvers }}\r\n\t\ttype {{$object.GQLType}}Resolver interface {\r\n\t\t{{ range $field := $object.Fields -}}\r\n\t\t\t{{ $field.ShortResolverDeclaration }}\r\n\t\t{{ end }}\r\n\t\t}\r\n\t{{- end }}\r\n{{- end }}\r\n\r\ntype executableSchema struct {\r\n\tresolvers  ResolverRoot\r\n\tdirectives DirectiveRoot\r\n}\r\n\r\nfunc (e *executableSchema) Schema() *ast.Schema {\r\n\treturn parsedSchema\r\n}\r\n\r\nfunc (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {\r\n\t{{- if .QueryRoot }}\r\n\t\tec := executionContext{graphql.GetRequestContext(ctx), e}\r\n\r\n\t\tbuf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {\r\n\t\t\tdata := ec._{{.QueryRoot.GQLType}}(ctx, op.SelectionSet)\r\n\t\t\tvar buf bytes.Buffer\r\n\t\t\tdata.MarshalGQL(&buf)\r\n\t\t\treturn buf.Bytes()\r\n\t\t})\r\n\r\n\t\treturn &graphql.Response{\r\n\t\t\tData:   buf,\r\n\t\t\tErrors: ec.Errors,\r\n\t\t}\r\n\t{{- else }}\r\n\t\treturn graphql.ErrorResponse(ctx, \"queries are not supported\")\r\n\t{{- end }}\r\n}\r\n\r\nfunc (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {\r\n\t{{- if .MutationRoot }}\r\n\t\tec := executionContext{graphql.GetRequestContext(ctx), e}\r\n\r\n\t\tbuf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {\r\n\t\t\tdata := ec._{{.MutationRoot.GQLType}}(ctx, op.SelectionSet)\r\n\t\t\tvar buf bytes.Buffer\r\n\t\t\tdata.MarshalGQL(&buf)\r\n\t\t\treturn buf.Bytes()\r\n\t\t})\r\n\r\n\t\treturn &graphql.Response{\r\n\t\t\tData:   buf,\r\n\t\t\tErrors: ec.Errors,\r\n\t\t}\r\n\t{{- else }}\r\n\t\treturn graphql.ErrorResponse(ctx, \"mutations are not supported\")\r\n\t{{- end }}\r\n}\r\n\r\nfunc (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {\r\n\t{{- if .SubscriptionRoot }}\r\n\t\tec := executionContext{graphql.GetRequestContext(ctx), e}\r\n\r\n\t\tnext := ec._{{.SubscriptionRoot.GQLType}}(ctx, op.SelectionSet)\r\n\t\tif ec.Errors != nil {\r\n\t\t\treturn graphql.OneShot(&graphql.Response{Data: []byte(\"null\"), Errors: ec.Errors})\r\n\t\t}\r\n\r\n\t\tvar buf bytes.Buffer\r\n\t\treturn func() *graphql.Response {\r\n\t\t\tbuf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {\r\n\t\t\t\tbuf.Reset()\r\n\t\t\t\tdata := next()\r\n\r\n\t\t\t\tif data == nil {\r\n\t\t\t\t\treturn nil\r\n\t\t\t\t}\r\n\t\t\t\tdata.MarshalGQL(&buf)\r\n\t\t\t\treturn buf.Bytes()\r\n\t\t\t})\r\n\r\n\t\t\treturn &graphql.Response{\r\n\t\t\t\tData:   buf,\r\n\t\t\t\tErrors: ec.Errors,\r\n\t\t\t}\r\n\t\t}\r\n\t{{- else }}\r\n\t\treturn graphql.OneShot(graphql.ErrorResponse(ctx, \"subscriptions are not supported\"))\r\n\t{{- end }}\r\n}\r\n\r\ntype executionContext struct {\r\n\t*graphql.RequestContext\r\n\t*executableSchema\r\n}\r\n\r\n{{- range $object := .Objects }}\r\n\t{{ template \"object.gotpl\" $object }}\r\n\r\n\t{{- range $field := $object.Fields }}\r\n\t\t{{ template \"field.gotpl\" $field }}\r\n\t{{ end }}\r\n{{- end}}\r\n\r\n{{- range $interface := .Interfaces }}\r\n\t{{ template \"interface.gotpl\" $interface }}\r\n{{- end }}\r\n\r\n{{- range $input := .Inputs }}\r\n\t{{ template \"input.gotpl\" $input }}\r\n{{- end }}\r\n\r\nfunc (ec *executionContext) FieldMiddleware(ctx context.Context, next graphql.Resolver) interface{} {\r\n\t{{- if .Directives }}\r\n\trctx := graphql.GetResolverContext(ctx)\r\n\tfor _, d := range rctx.Field.Definition.Directives {\r\n\t\tswitch d.Name {\r\n\t\t{{- range $directive := .Directives }}\r\n\t\tcase \"{{$directive.Name}}\":\r\n\t\t\tif ec.directives.{{$directive.Name|ucFirst}} != nil {\r\n\t\t\t\t{{- if $directive.Args }}\r\n\t\t\t\t\trawArgs := d.ArgumentMap(ec.Variables)\r\n\t\t\t\t\t{{ template \"args.gotpl\" $directive.Args }}\r\n\t\t\t\t{{- end }}\r\n\t\t\t\tn := next\r\n\t\t\t\tnext = func(ctx context.Context) (interface{}, error) {\r\n\t\t\t\t\treturn ec.directives.{{$directive.Name|ucFirst}}({{$directive.CallArgs}})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t{{- end }}\r\n\t\t}\r\n\t}\r\n\t{{- end }}\r\n\tres, err := ec.ResolverMiddleware(ctx, next)\r\n\tif err != nil {\r\n\t\tec.Error(ctx, err)\r\n\t\treturn nil\r\n\t}\r\n\treturn res\r\n}\r\n\r\nfunc (ec *executionContext) introspectSchema() *introspection.Schema {\r\n\treturn introspection.WrapSchema(parsedSchema)\r\n}\r\n\r\nfunc (ec *executionContext) introspectType(name string) *introspection.Type {\r\n\treturn introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])\r\n}\r\n\r\nvar parsedSchema = gqlparser.MustLoadSchema(\r\n\t&ast.Source{Name: {{.SchemaFilename|quote}}, Input: {{.SchemaRaw|rawQuote}}},\r\n)\r\n",
	"input.gotpl":     "\t{{- if .IsMarshaled }}\r\n\tfunc Unmarshal{{ .GQLType }}(v interface{}) ({{.FullName}}, error) {\r\n\t\tvar it {{.FullName}}\r\n\t\tvar asMap = v.(map[string]interface{})\r\n\t\t{{ range $field := .Fields}}\r\n\t\t\t{{- if $field.Default}}\r\n\t\t\t\tif _, present := asMap[{{$field.GQLName|quote}}] ; !present {\r\n\t\t\t\t\tasMap[{{$field.GQLName|quote}}] = {{ $field.Default | dump }}\r\n\t\t\t\t}\r\n\t\t\t{{- end}}\r\n\t\t{{- end }}\r\n\r\n\t\tfor k, v := range asMap {\r\n\t\t\tswitch k {\r\n\t\t\t{{- range $field := .Fields }}\r\n\t\t\tcase {{$field.GQLName|quote}}:\r\n\t\t\t\tvar err error\r\n\t\t\t\t{{ $field.Unmarshal (print \"it.\" $field.GoFieldName) \"v\" }}\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\treturn it, err\r\n\t\t\t\t}\r\n\t\t\t{{- end }}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn it, nil\r\n\t}\r\n\t{{- end }}\r\n",
	"interface.gotpl": "{{- $interface := . }}\r\n\r\nfunc (ec *executionContext) _{{$interface.GQLType}}(ctx context.Context, sel ast.SelectionSet, obj *{{$interface.FullName}}) graphql.Marshaler {\r\n\tswitch obj := (*obj).(type) {\r\n\tcase nil:\r\n\t\treturn graphql.Null\r\n\t{{- range $implementor := $interface.Implementors }}\r\n\t\t{{- if $implementor.ValueReceiver }}\r\n\t\t\tcase {{$implementor.FullName}}:\r\n\t\t\t\treturn ec._{{$implementor.GQLType}}(ctx, sel, &obj)\r\n\t\t{{- end}}\r\n\t\tcase *{{$implementor.FullName}}:\r\n\t\t\treturn ec._{{$implementor.GQLType}}(ctx, sel, obj)\r\n\t{{- end }}\r\n\tdefault:\r\n\t\tpanic(fmt.Errorf(\"unexpected type %T\", obj))\r\n\t}\r\n}\r\n",
	"models.gotpl":    "// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\n\npackage {{ .PackageName }}\n\nimport (\n{{- range $import := .Imports }}\n\t{{- $import.Write }}\n{{ end }}\n)\n\n{{ range $model := .Models }}\n\t{{- if .IsInterface }}\n\t\ttype {{.GoType}} interface {}\n\t{{- else }}\n\t\ttype {{.GoType}} struct {\n\t\t\t// {{ .IsInput }}\n\t\t\t{{- range $field := .Fields }}\n\t\t\t\t{{- if $field.GoFieldName }}\n\t\t\t\t\t{{- if $model.IsInput }}\n\t\t\t\t\t\t{{ $field.GoFieldName }} {{$field.UnmarshaledSignature}} `json:\"{{$field.GQLName}}\"`\n\t\t\t\t\t{{- else }}\n\t\t\t\t\t\t{{ $field.GoFieldName }} {{$field.Signature}} `json:\"{{$field.GQLName}}\"`\n\t\t\t\t\t{{- end }}\n\t\t\t\t{{- else }}\n\t\t\t\t\t{{ $field.GoFKName }} {{$field.GoFKType}}\n\t\t\t\t{{- end }}\n\t\t\t{{- end }}\n\t\t}\n\t{{- end }}\n{{- end}}\n\n{{ range $enum := .Enums }}\n\ttype {{.GoType}} string\n\tconst (\n\t{{ range $value := .Values -}}\n\t\t{{with .Description}} {{.|prefixLines \"// \"}} {{end}}\n\t\t{{$enum.GoType}}{{ .Name|toCamel }} {{$enum.GoType}} = {{.Name|quote}}\n\t{{- end }}\n\t)\n\n\tfunc (e {{.GoType}}) IsValid() bool {\n\t\tswitch e {\n\t\tcase {{ range $index, $element := .Values}}{{if $index}},{{end}}{{ $enum.GoType }}{{ $element.Name|toCamel }}{{end}}:\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tfunc (e {{.GoType}}) String() string {\n\t\treturn string(e)\n\t}\n\n\tfunc (e *{{.GoType}}) UnmarshalGQL(v interface{}) error {\n\t\tstr, ok := v.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"enums must be strings\")\n\t\t}\n\n\t\t*e = {{.GoType}}(str)\n\t\tif !e.IsValid() {\n\t\t\treturn fmt.Errorf(\"%s is not a valid {{.GQLType}}\", str)\n\t\t}\n\t\treturn nil\n\t}\n\n\tfunc (e {{.GoType}}) MarshalGQL(w io.Writer) {\n\t\tfmt.Fprint(w, strconv.Quote(e.String()))\n\t}\n\n{{- end }}\n",
	"object.gotpl":    "{{ $object := . }}\r\n\r\nvar {{ $object.GQLType|lcFirst}}Implementors = {{$object.Implementors}}\r\n\r\n// nolint: gocyclo, errcheck, gas, goconst\r\n{{- if .Stream }}\r\nfunc (ec *executionContext) _{{$object.GQLType}}(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {\r\n\tfields := graphql.CollectFields(ctx, sel, {{$object.GQLType|lcFirst}}Implementors)\r\n\tctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{\r\n\t\tObject: {{$object.GQLType|quote}},\r\n\t})\r\n\tif len(fields) != 1 {\r\n\t\tec.Errorf(ctx, \"must subscribe to exactly one stream\")\r\n\t\treturn nil\r\n\t}\r\n\r\n\tswitch fields[0].Name {\r\n\t{{- range $field := $object.Fields }}\r\n\tcase \"{{$field.GQLName}}\":\r\n\t\treturn ec._{{$object.GQLType}}_{{$field.GQLName}}(ctx, fields[0])\r\n\t{{- end }}\r\n\tdefault:\r\n\t\tpanic(\"unknown field \" + strconv.Quote(fields[0].Name))\r\n\t}\r\n}\r\n{{- else }}\r\nfunc (ec *executionContext) _{{$object.GQLType}}(ctx context.Context, sel ast.SelectionSet{{if not $object.Root}}, obj *{{$object.FullName}} {{end}}) graphql.Marshaler {\r\n\tfields := graphql.CollectFields(ctx, sel, {{$object.GQLType|lcFirst}}Implementors)\r\n\t{{if $object.Root}}\r\n\t\tctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{\r\n\t\t\tObject: {{$object.GQLType|quote}},\r\n\t\t})\r\n\t{{end}}\r\n\tout := graphql.NewOrderedMap(len(fields))\r\n\tfor i, field := range fields {\r\n\t\tout.Keys[i] = field.Alias\r\n\r\n\t\tswitch field.Name {\r\n\t\tcase \"__typename\":\r\n\t\t\tout.Values[i] = graphql.MarshalString({{$object.GQLType|quote}})\r\n\t\t{{- range $field := $object.Fields }}\r\n\t\tcase \"{{$field.GQLName}}\":\r\n\t\t\tout.Values[i] = ec._{{$object.GQLType}}_{{$field.GQLName}}(ctx, field{{if not $object.Root}}, obj{{end}})\r\n\t\t{{- end }}\r\n\t\tdefault:\r\n\t\t\tpanic(\"unknown field \" + strconv.Quote(field.Name))\r\n\t\t}\r\n\t}\r\n\r\n\treturn out\r\n}\r\n{{- end }}\r\n",
	"resolver.gotpl":  "//go:generate gorunpkg github.com/99designs/gqlgen\r\n\r\npackage {{ .PackageName }}\r\n\r\nimport (\r\n{{- range $import := .Imports }}\r\n\t{{- $import.Write }}\r\n{{ end }}\r\n)\r\n\r\ntype {{.ResolverType}} struct {}\r\n\r\n{{ range $object := .Objects -}}\r\n\t{{- if $object.HasResolvers -}}\r\n\t\tfunc (r *{{$.ResolverType}}) {{$object.GQLType}}() {{ $object.ResolverInterface.FullName }} {\r\n\t\t\treturn &{{lcFirst $object.GQLType}}Resolver{r}\r\n\t\t}\r\n\t{{ end -}}\r\n{{ end }}\r\n\r\n{{ range $object := .Objects -}}\r\n\t{{- if $object.HasResolvers -}}\r\n\t\ttype {{lcFirst $object.GQLType}}Resolver struct { *Resolver }\r\n\r\n\t\t{{ range $field := $object.Fields -}}\r\n\t\t\t{{- if $field.IsResolver -}}\r\n\t\t\tfunc (r *{{lcFirst $object.GQLType}}Resolver) {{ $field.ShortResolverDeclaration }} {\r\n\t\t\t\tpanic(\"not implemented\")\r\n\t\t\t}\r\n\t\t\t{{ end -}}\r\n\t\t{{ end -}}\r\n\t{{ end -}}\r\n{{ end }}\r\n",
	"server.gotpl":    "package main\r\n\r\nimport (\r\n{{- range $import := .Imports }}\r\n\t{{- $import.Write }}\r\n{{ end }}\r\n)\r\n\r\nconst defaultPort = \"8080\"\r\n\r\nfunc main() {\r\n\tport := os.Getenv(\"PORT\")\r\n\tif port == \"\" {\r\n\t\tport = defaultPort\r\n\t}\r\n\r\n\thttp.Handle(\"/\", handler.Playground(\"GraphQL playground\", \"/query\"))\r\n\thttp.Handle(\"/query\", handler.GraphQL({{.ExecPackageName}}.NewExecutableSchema({{.ExecPackageName}}.Config{Resolvers: &{{.ResolverPackageName}}.Resolver{}})))\r\n\r\n\tlog.Printf(\"connect to http://localhost:%s/ for GraphQL playground\", port)\r\n\tlog.Fatal(http.ListenAndServe(\":\" + port, nil))\r\n}\r\n",
}
